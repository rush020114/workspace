<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- 해당 파일에 모든 쿼리문을 작성 -->
<!-- namespace에는 xml파일과 연결할 Mapper interface 파일명을 패키지를 포함하여 적어주세요 -->
<mapper namespace="com.green.backend_shop.cart.mapper.CartMapper">
	<resultMap id="cart" type="com.green.backend_shop.cart.dto.CartDTO">
        <id     column="CART_NUM" property="cartNum" />
        <result column="BOOK_NUM" property="bookNum" />
        <result column="CART_CNT" property="cartCnt" />
        <result column="TOTAL_PRICE" property="totalPrice" />
        <result column="MEM_ID" property="memId" />
        <result column="CART_DATE" property="cartDate" />
        <!--
        조인을 사용 시 두 테이블의 관계를 생각해야 한다.(1:1인지 1:n인지)
        자신이 만들 기능이 기준이 된다.(현재는 장바구니 기능을 만들기 때문에 기준이 장바구니가 된다.)
        장바구니 하나당 하나의 상품이 성립(1:1)한다.(여러 장바구니도 그 개수만큼의 상품이 성립)
        DTO에 정의해준 관계를 resultMap에서도 부여해준다.
        associate의 resultMap에는 join을 위해 사용할 DTO에 연결되어 있는 resultMap id를 넣는다.
        다른 파일에 있는 resultMap을 받아오기 위해선 그 파일의 namespace.id를 해준다.
        join으로 조회된 컬럼은 column에 없으므로 association을 보게 된다.
        그러면 association resultMap를 읽고 참조하게 되는데 그 id를 보면 join으로 조회된 컬럼의 column이 존재하므로
        그 곳의 dto에 join으로 조회된 컬럼을 넣을 수 있기 때문에 이 파일의 dto에 join 조회 컬럼이 들어간다.
        -->
        <!--
         장바구니 목록 조회 시 3개의 테이블을 동시에 조회한다.
         그래서 3개 각각의 관계를 파악해 ASSOCIATION이나 COLLECTION 태그를 각각 써줘야 할 것 같지만
         이미 bookDTO에 bookImgDTOLIST의 관계가 성립하기에 조회한 데이터에서 resultMap으로 bookImg를 찾을 때
         bookDTO를 통해서 접근 가능하게끔 설계가 되어 있기 때문에 태그를 추가할 필요가 없다.
         결로은 장바구니 테이블을 조회할 시
         장바구니 테이블 : 책 : 책 이미지 = 1 : 1 : n 관계가 이 resultMap을 통해 잘 정의되어 있다.
        -->
        <association property="bookDTO" resultMap="com.green.backend_shop.book.mapper.BookMapper.book" />
    </resultMap>

    <!-- 장바구니 목록 조회 -->
    <select id="getCartList" resultMap="cart">
        SELECT CART_NUM
        , C.BOOK_NUM
        , TITLE
        , PRICE
        , CART_CNT
        , TOTAL_PRICE
        , CART_DATE
        , ATTACHED_IMG_NAME
        FROM SHOP_CART C
        INNER JOIN BOOK B
        ON B.BOOK_NUM = C.BOOK_NUM
        INNER JOIN BOOK_IMG I
        <!--
         JOIN을 두 개 이상 쓴다면 두 번째 조인 때는
         조인을 거는 테이블에 있는 컬럼과 나머지 두 테이블 중 같은 컬럼이 있는 테이블을 연결하면 된다.
        -->
        ON C.BOOK_NUM = I.BOOK_NUM
        WHERE MEM_ID = #{memId}
        AND IS_MAIN = 'Y'
        ORDER BY CART_DATE DESC
    </select>

    <!-- 장바구니 등록 -->
    <insert id="insertCart">
        INSERT INTO SHOP_CART (
        BOOK_NUM
        , CART_CNT
        , TOTAL_PRICE
        , MEM_ID
        ) VALUES (
        #{bookNum}
        , #{cartCnt}
        , (
        SELECT PRICE
        FROM BOOK
        WHERE BOOK_NUM = #{bookNum}
        ) * #{cartCnt}
        , #{memId}
        )
    </insert>

    <!-- 쿼리를 미리 파악한 후 작성해야 어떤 데이터를 넘겨야 할지 알 수 있다. -->
    <!-- 장바구니 등록 시 중복 확인 중복이면 수정 -->
    <!-- 장바구니 중복만 확인하면 되는데 참조자료형이어야 null데이터를 받을 수 있으므로 String을 조회하게끔 해준다. -->
    <!-- 아이디와 북번호를 조회해야 0 또는 1개의 데이터만 나온다. -->
    <select id="getCartForDup" resultType="String">
        SELECT MEM_ID
        FROM SHOP_CART
        WHERE MEM_ID = #{memId}
        AND BOOK_NUM = #{bookNum}
    </select>

    <!-- 중복 시 수정할 데이터 -->
    <update id="updateCart">
        UPDATE SHOP_CART
        SET CART_CNT = CART_CNT + #{cartCnt}
            , TOTAL_PRICE = (SELECT PRICE
                            FROM BOOK
                            WHERE BOOK_NUM = #{bookNum}) * CART_CNT
        WHERE BOOK_NUM = #{bookNum}
        AND MEM_ID = #{memId}
    </update>

    <!-- 장바구니 삭제 -->
    <delete id="deleteCart">
        DELETE FROM SHOP_CART
        WHERE CART_NUM = #{cartNum}
    </delete>

    <!-- 장바구니 수량 수정 -->
    <update id="updateCartCnt">
        UPDATE SHOP_CART
        SET CART_CNT = #{cartCnt}
            , TOTAL_PRICE = (SELECT PRICE
                            FROM BOOK
                            WHERE BOOK_NUM = #{bookNum}) * #{cartCnt}
        WHERE CART_NUM = #{cartNum}
    </update>

    <!-- 장바구니 구매 시 목록 삭제 -->
    <!--
      장바구니 구매 목록 삭제는 장바구니에서 상품이 구매될 시 진행되기 때문에
      기능이 하나고 쿼리가 여러개인 경우라고 볼 수 있다.
      기능이 하나일 땐 service의 한 메서드에 작성하는 것이 원칙이다.
      이를 어기면 transaction을 적용할 수 없어 예외 상황을 처리할 수가 없다.
      transaction은 간단히 설명하면 한 메서드에서 여러 쿼리를 한 묶음으로 묶어주는 것이다.
      그러면 한 쿼리가 잘못되면 이전에 실행된 모든 쿼리를 rollback시키고 다 완료될 때만 commit을 하여 오류를 예방할 수 있다.
    -->
    <delete id="deleteCarts">
        DELETE FROM SHOP_CART
        WHERE CART_NUM IN
        <foreach collection="cartNumList" item="cartNum" separator="," open="(" close=")">
            #{cartNum}
        </foreach>
    </delete>
</mapper>