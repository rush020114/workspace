// 구조분해할당은 배열, 객체를 분해하여 일부분의 데이터를 다른 변수에 할당
// 배열을 저장하는가 객체를 저장하는가에 따라 변수 선언에 필요한 괄호를 다르게 한다.
// 괄호는 자료저장 방식에 사용하는 괄호와 똑같이 하면 된다.

// 배열의 각각의 데이터를 대괄호 안의 각각 변수에 순서대로 넣겠다.
const [a1, b1, c1] = [1, 2, 3];
console.log(a1);

// 순서대로 저장되므로 7은 저장되지 않는다.
const [a2, b2] = [3, 5, 7];

// c3에는 값이 들어가지 못하는데 선언만 되어 undefined가 나오게 된다.
// 변수가 만들어지지 않았거나 만들어졌는데 값이 저장되지 않으면 undefined가 나온다.
const [a3, b3, c3] = [1, 4];
console.log(c3);

// 객체의 구조분해할당
const student = {
  name: 'hong',
  age : 20,
  score: 80
};

// 원래는 각각의 데이터를 밑의 방법대로 저장할 수밖에 없다.
const myName = student.name;

// 객체는 자료구조 방식이 key값을 사용한다.
// 저장될 변수가 key값과 다르고 저장될 공간이 있다면 값을 저장할 수 없어 undefined가 된다.
const {name, age, score} = student;

// 구조분해할당을 함수로 작성할 수 있다.
// 매개변수자리에 저장될 값을 생각하면 문법이 그려지고
// 매개변수자리에 들어오는 값과 매개변수를 합쳤을 때
// 구조분해할당 문법이 나오면 구조분해할당이 되므로
// 매개변수자리에 들어갈 배열들을 작성하면 구조분해할당을 할 수 있는 함수가 완성된다. 
const f1 = ([a1, b1, c1,]) => a1 + b1 + c1; 
console.log(f1([1,2,3]))

// 배열뿐만 아니라 객체도 가능하다.
// 출력문에 쉼표를 넣으면 나열된다.
const f2 = ({name, age, score}) => console.log(name, age, score);

f2({name: 'kim', age: 20, score: 80});

const stu = {
  name: 'lee',
  age: 30,
  score: 90
};

f2(stu); // 객체를 구조분해할당해주어 각 value를 나열하여 출력해주는 함수 호출문.