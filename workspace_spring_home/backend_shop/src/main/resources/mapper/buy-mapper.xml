<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- 해당 파일에 모든 쿼리문을 작성 -->
<!-- namespace에는 xml파일과 연결할 Mapper interface 파일명을 패키지를 포함하여 적어주세요 -->
<mapper namespace="com.green.backend_shop.buy.mapper.BuyMapper">
    <!-- shop_buy의 조회된 컬럼을 받기 위한 정의문 -->
	<resultMap id="buy" type="com.green.backend_shop.buy.dto.BuyDTO">
        <id     column="BUY_NUM"  property="buyNum" />
        <result column="BOOK_NUM" property="bookNum" />
        <result column="MEM_ID"   property="memId" />
        <result column="BUY_DATE" property="buyDate" />
        <result column="BUY_CNT"  property="buyCnt" />
    </resultMap>

    <!-- 도서 구매 -->
    <insert id="buyBook">
        INSERT INTO SHOP_BUY (
            BOOK_NUM
            , MEM_ID
            , BUY_CNT
        ) VALUES (
            #{bookNum}
            , #{memId}
            , #{buyCnt}
        )
    </insert>
    
    <!-- 장바구니 도서 구매 -->
    <!--
      장바구니 페이지에서 물품을 구매하기 위해 채워져야 할 빈값이 많이 존재한다.
      같은 컬럼이라도 들어가는 빈값이 각각 다르면 dto로 받아오기 힘들다.
      memId는 공통값이라 dto에 일반적인 방법으로 담아오면 되지만 나머지 컬럼은 값이 변하기 때문에
      공동으로 묶을 수 있는 컬럼을 찾아 서브쿼리로 작성한다.
      공동으로 묶을 수 있는 쿼리를 알게 되면 react에서 전달할 데이터(리스트)가 적어지니 코드가 편해집니다.
      이 경우엔 장바구니 페이지에선 cartNum으로 이 쿼리에 필요한 값을 조회할 수 있으므로 빈값을 공동으로 묶을 수 있다.
      그리고 collection은 dto를 받게 되며 dto를 받았을 때 적힌 변수명의 getter를 호출해 반복문을 돌린다.
      그러니까 dto안의 배열을 돌릴 수 있게 되는 것이다.
      그 각각의 데이터는 cartNum으로 받아서 mybatis변수명을 cartNum으로 할 수 있다.
      단, dto가 전달되지 않을 땐 전달되는 변수명과 collection의 변수명을 같게 해준다.
    -->
    <insert id="buyCartBook">
        INSERT INTO SHOP_BUY (
            BOOK_NUM
            , MEM_ID
            , BUY_CNT
        ) VALUES
        <foreach collection="cartNumList" item="cartNum" separator=",">
            ((SELECT BOOK_NUM FROM SHOP_CART WHERE CART_NUM = #{cartNum})
            , #{memId}
            , (SELECT CART_CNT FROM SHOP_CART WHERE CART_NUM = #{cartNum}))
        </foreach>
    </insert>
</mapper>